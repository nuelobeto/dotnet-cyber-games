@page "/pac-man"
@using System.Timers
@implements IDisposable
@inject IJSRuntime JS
@rendermode InteractiveServer

<PageTitle>Cyber Games: Packet Sniffer</PageTitle>

@* The @onkeydown.prevent stops the arrow keys from scrolling the webpage *@
<div class="game-wrapper" 
     @ref="gameRef" 
     @onkeydown="HandleKeyDown" 
     @onkeydown:preventDefault="true"
     tabindex="0">
    
    <div class="stats">
        <span>Fragments Leaked: @score</span> | 
        <span>Status: <span class="status-active">@status</span></span>
    </div>

    <div class="game-container">
        @if (!isRunning && score == 0)
        {
            <div class="start-overlay">
                <p>TERMINAL LINK ESTABLISHED</p>
                <button class="btn-main pulse" @onclick="StartGame">INITIALIZE EXPLOIT</button>
            </div>
        }

        @for (int row = 0; row < grid.GetLength(0); row++)
        {
            <div class="grid-row">
                @for (int col = 0; col < grid.GetLength(1); col++)
                {
                    var r = row;
                    var c = col;
                    <div class="cell @GetCellClass(r, c)">
                        @if (playerRow == r && playerCol == c) { <div class="player"></div> }
                        @if (ghostRow == r && ghostCol == c) { <div class="ghost"></div> }
                    </div>
                }
            </div>
        }
    </div>

    <div class="ui-footer">
        <div class="instructions">TERMINAL ACTIVE: USE ARROW KEYS</div>
        <div class="actions">
            @if (isRunning)
            {
                <button class="btn-main" @onclick="StopGame">PAUSE</button>
            }
            <button class="btn-main" @onclick="ResetGame">PURGE SYSTEM (RESET)</button>
        </div>
    </div>
</div>

@code {
    private ElementReference gameRef;
    private int score = 0;
    private string status = "READY";
    private bool isRunning = false;
    private Timer? gameTimer;

    private int playerRow = 1, playerCol = 1;
    private int ghostRow = 5, ghostCol = 13;
    private int dr = 0, dc = 1;

    private int[,] grid = {
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,1,0,0,0,0,0,1,0,0,0,1},
        {1,0,1,0,1,0,1,1,1,0,1,0,1,0,1},
        {1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
        {1,1,1,0,1,1,0,1,0,1,1,0,1,1,1},
        {1,0,0,0,0,0,0,1,0,0,0,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Try to focus on load, and again after any state change if needed
        try 
        {
            await gameRef.FocusAsync();
            // Optional: A little JS fallback if FocusAsync is being stubborn
            await JS.InvokeVoidAsync("eval", "document.querySelector('.game-wrapper').focus()");
        }
        catch { /* Ignore JS errors during pre-rendering */ }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowUp": dr = -1; dc = 0; break;
            case "ArrowDown": dr = 1; dc = 0; break;
            case "ArrowLeft": dr = 0; dc = -1; break;
            case "ArrowRight": dr = 0; dc = 1; break;
        }
    }

    private void StartGame()
    {
        if (isRunning) return;
        isRunning = true;
        status = "INFILTRATING...";
        gameTimer = new Timer(250);
        gameTimer.Elapsed += OnGameTick;
        gameTimer.AutoReset = true;
        gameTimer.Enabled = true;
    }

    private async void OnGameTick(object? sender, ElapsedEventArgs e)
    {
        MovePlayer();
        MoveGhost();
        CheckCollision();
        await InvokeAsync(StateHasChanged);
    }

    private void MovePlayer()
    {
        int nextR = playerRow + dr;
        int nextC = playerCol + dc;

        if (nextR >= 0 && nextR < grid.GetLength(0) && nextC >= 0 && nextC < grid.GetLength(1))
        {
            if (grid[nextR, nextC] != 1)
            {
                playerRow = nextR;
                playerCol = nextC;
                if (grid[playerRow, playerCol] == 0)
                {
                    grid[playerRow, playerCol] = 2;
                    score += 10;
                }
            }
        }
    }

    private void MoveGhost()
    {
        if (ghostRow < playerRow && grid[ghostRow + 1, ghostCol] != 1) ghostRow++;
        else if (ghostRow > playerRow && grid[ghostRow - 1, ghostCol] != 1) ghostRow--;
        else if (ghostCol < playerCol && grid[ghostRow, ghostCol + 1] != 1) ghostCol++;
        else if (ghostCol > playerCol && grid[ghostRow, ghostCol - 1] != 1) ghostCol--;
    }

    private void CheckCollision()
    {
        if (playerRow == ghostRow && playerCol == ghostCol)
        {
            StopGame();
            status = "ACCESS DENIED (CAUGHT)";
        }
    }

    private void StopGame() { isRunning = false; gameTimer?.Stop(); }

    private void ResetGame()
    {
        StopGame();
        playerRow = 1; playerCol = 1;
        ghostRow = 5; ghostCol = 13;
        dr = 0; dc = 1;
        score = 0;
        status = "READY";
        
        for (int i = 0; i < grid.GetLength(0); i++)
            for (int j = 0; j < grid.GetLength(1); j++)
                if (grid[i, j] == 2) grid[i, j] = 0;
    }

    private string GetCellClass(int r, int c) => grid[r, c] switch {
        1 => "wall",
        0 => "dot",
        _ => "empty"
    };

    public void Dispose() => gameTimer?.Dispose();
}

<style>
    .game-wrapper {
        max-width: 600px;
        margin: 40px auto;
        background: #0d1117;
        color: #00ff41;
        font-family: 'Courier New', Courier, monospace;
        padding: 30px;
        border: 2px solid #00ff41;
        text-align: center;
        outline: none;
        position: relative;
    }

    .stats { font-size: 1.1rem; margin-bottom: 20px; border-bottom: 1px dashed #333; padding-bottom: 10px; }
    .status-active { color: #ff003c; }

    .game-container {
        display: inline-block;
        background: #000;
        border: 2px solid #16213e;
        padding: 4px;
        position: relative;
    }

    .start-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8);
        z-index: 10;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .grid-row { display: flex; }
    .cell { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; }
    .wall { background: #16213e; box-shadow: inset 0 0 5px #000; }
    .dot::after { content: ""; width: 5px; height: 5px; background: #00ff41; border-radius: 50%; }
    
    .player {
        width: 24px; height: 24px; background: #00ff41; border-radius: 50%;
        box-shadow: 0 0 10px #00ff41;
    }
    
    .ghost {
        width: 24px; height: 24px; background: #ff003c;
        clip-path: polygon(0% 100%, 0% 20%, 20% 0%, 80% 0%, 100% 20%, 100% 100%, 80% 80%, 60% 100%, 40% 80%, 20% 100%);
    }

    .ui-footer { margin-top: 25px; }
    .instructions { font-size: 0.8rem; color: #888; margin-bottom: 15px; letter-spacing: 2px; }

    .btn-main {
        background: #16213e;
        color: #00ff41;
        border: 1px solid #00ff41;
        padding: 10px 20px;
        cursor: pointer;
        font-family: inherit;
    }

    .pulse { animation: neon-pulse 1.5s infinite; }
    @@keyframes neon-pulse {
        0% { box-shadow: 0 0 0px #00ff41; }
        50% { box-shadow: 0 0 15px #00ff41; }
        100% { box-shadow: 0 0 0px #00ff41; }
    }

    .btn-main:hover { background: #00ff41; color: #000; }
</style>